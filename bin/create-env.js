// @ts-check
const { resolve } = require('path');
const { writeFile } = require('fs');
// @ts-ignore
const { argv } = require('yargs');
const { checkEnvironment } = require('./utils');
// @ts-ignore
const pkg = require('../package.json');

// This is good for local dev environments, when it's better to
// store a projects environment variables in a .gitignore'd file
require('dotenv').config();

checkEnvironment([
	'ASSET_CDN_HOST',
	'COCKPIT_API_URL',
	'COCKPIT_API_KEY',
	'GRAPHQL_HOST_URL',
	'GTM_ID',
	'GCP_KEY',
	'GCP_STATIC_MAPS_SECRET',
	'SLACK_ERROR_HOOK_URL'
]);

// Would be passed to script like this:
// `ts-node set-env.ts --environment=dev`
// we get it from yargs's argv object
const environment = argv.environment;
const isProd = environment === 'prod' || environment === 'production';

const targetPath = resolve(__dirname, `../src/environments/environment${environment ? `.${environment}` : ''}.ts`);
const envConfigFile =
	(isProd
		? `/* ${new Date().toISOString()} */`
		: `/**
 * DO NOT MODIFY THIS FILE DIRECTLY
 * Autogenerated file by the bin/create-env.js script
 * @generated ${new Date().toISOString()}
 */`) +
	`
export const environment = {
	production: ${isProd},
	buildNumber: 'v${pkg.version}#${Date.now()}',
	assetCDNHost: '${process.env.ASSET_CDN_HOST}',
	cockpitAPIURL: '${process.env.COCKPIT_API_URL}',
	cockpitAPIKey: '${process.env.COCKPIT_API_KEY}',
	graphQLHostURL: '${process.env.GRAPHQL_HOST_URL}',
	gtmId: '${process.env.GTM_ID}',
	gcpKey: '${process.env.GCP_KEY}',
	gcpStaticMapsSecret: '${process.env.GCP_STATIC_MAPS_SECRET}',
	slackErrorHookURL: '${process.env.SLACK_ERROR_HOOK_URL}',
};
${!isProd ? `import 'zone.js/dist/zone-error';` : ''}
`;
writeFile(targetPath, envConfigFile, function(err) {
	if (err) {
		console.log(err);
	}

	console.log(`ðŸ›  Environment generated at ${targetPath}`);
});
